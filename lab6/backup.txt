package eecs2030.lab6;

import java.awt.Color;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * A utility class containing recursive methods.
 * 
 * @author EECS2030 Fall 2016
 *
 */
public class Recursion {

	// DON'T ADD ANY STATIC FIELDS; YOU DON'T STATIC FIELDS AND YOUR METHODS
	// WON'T WORK CORRECTLY IF YOU USE STATIC FIELDS

	private Recursion() {
		// empty by design
	}

	/**
	 * Return the sum of the integers 1 through n where n is a strictly positive
	 * integer. Note that the sum might overflow if n is too large; this method
	 * does not check if the sum overflows (i.e., it's the client's problem).
	 * 
	 * @pre n is greater than 0
	 * 
	 * @param n
	 *            a strictly positive number
	 * @return the sum 1 + 2 + ... + n
	 */
	public static int sum(int n) {
		if (n == 1)
			return 1;
		return n + sum(n - 1);
	}

	/**
	 * Returns a new string equal to the reversal of string s. The reversal of
	 * the empty string is equal to the empty string.
	 * 
	 * @pre s is not null
	 * 
	 * @param s
	 *            a string
	 * @return a string equal to the reversal of s
	 */
	public static String reverse(String s) {
		if (s.length() < 2)
			return s;
		return reverse(s.substring(1)) + s.charAt(0);
	}

	/**
	 * Returns the minimum element in the list t. This method does not modify
	 * the list <code>t</code>.
	 * 
	 * @pre t.size() is greater than 0
	 * 
	 * @param t
	 *            a non-empty list
	 * @return the minimum element in t
	 */
	public static int min(List<Integer> t) {
		if (t.size() == 1)
			return t.get(0);
		return Math.min(t.get(0), min(t.subList(1, t.size())));
	}

	/**
	 * Downsample a picture <code>n</code> times by a factor of 2 using
	 * recursion. See the lab problem for a description of downsampling.
	 * 
	 * @pre the width and height of the picture are both multiples of 2 to the
	 *      power n
	 * 
	 * @pre1 n is greater than or equal to zero
	 * 
	 * @param p
	 *            the picture to downsample
	 * @param n
	 *            the number of times to downsample the picture by a factor of 2
	 * @return the downsampled picture
	 */

	public static Picture downsample(Picture p, int n) {
		if (n == 0)
			return p;

		Picture[][] pic = new Picture[2][2];
		int halfW = p.width() / 4, halfH = p.height() / 4;
		pic[0][0] = new Picture(-Math.floorDiv(-p.width(), 4), -Math.floorDiv(-p.height(), 4));
		pic[1][0] = new Picture(-Math.floorDiv(-p.width(), 4), halfH);
		pic[0][1] = new Picture(halfW, -Math.floorDiv(-p.height(), 4));
		pic[1][1] = new Picture(halfW, halfH);

		System.out.println(-Math.floorDiv(-p.height(), 4));

		Color[][] color = clr(p.width(), p.height(), p);

		for (int i = 0; i < -Math.floorDiv(-p.width(), 4); i++) {
			for (int g = 0; g < -Math.floorDiv(-p.height(), 4); g++) {
				pic[0][0].set(i, g, color[i][g]);
			}
		}
		for (int i = 0; i < -Math.floorDiv(-p.width(), 4); i++) {
			for (int g = 0; g < halfH; g++) {
				pic[1][0].set(i, g, color[i][g + -Math.floorDiv(-p.height(), 4)]);
			}
		}
		for (int i = 0; i < halfW; i++) {
			for (int g = 0; g < -Math.floorDiv(-p.height(), 4); g++) {
				pic[0][1].set(i, g, color[i + -Math.floorDiv(-p.width(), 4)][g]);
			}
		}
		for (int i = 0; i < halfW; i++) {
			for (int g = 0; g < halfH; g++) {
				pic[1][1].set(i, g, color[i + -Math.floorDiv(-p.width(), 4)][g + -Math.floorDiv(-p.height(), 4)]);
			}
		}

		int width = -p.width();
		for (int i = 0; i < n; i++)
			Math.floorDiv(width, 2);
		
		int height = -p.height();
		for (int i = 0; i < n; i++)
			Math.floorDiv(height, 2);
		
		Picture newP = new Picture(-Math.floorDiv(-p.width(), (int) Math.pow(2, n)),
				-Math.floorDiv(-p.height(), (int) Math.pow(2, n)));

		pic[0][0] = downsample(pic[0][0], n - 1);
		pic[1][0] = downsample(pic[1][0], n - 1);
		pic[0][1] = downsample(pic[0][1], n - 1);
		pic[1][1] = downsample(pic[1][1], n - 1);

		halfW = newP.width() / 2;
		halfH = newP.height() / 2;

		for (int i = 0; i < -Math.floorDiv(-p.width(), (int) Math.pow(2, n + 1)); i++) {
			for (int g = 0; g < -Math.floorDiv(-p.height(), (int) Math.pow(2, n + 1)); g++) {
				newP.set(i, g, pic[0][0].get(i, g));
			}
		}
		for (int i = 0; i < -Math.floorDiv(-p.width(), (int) Math.pow(2, n + 1)); i++) {
			for (int g = 0; g < halfH; g++) {
				newP.set(i, g + -Math.floorDiv(-p.height(), (int) Math.pow(2, n + 1)), pic[1][0].get(i, g));
			}
		}
		for (int i = 0; i < halfW; i++) {
			for (int g = 0; g < -Math.floorDiv(-p.height(), (int) Math.pow(2, n + 1)); g++) {
				newP.set(i + -Math.floorDiv(-p.width(), (int) Math.pow(2, n + 1)), g, pic[0][1].get(i, g));
			}
		}
		for (int i = 0; i < halfW; i++) {
			for (int g = 0; g < halfH; g++) {
				newP.set(i + -Math.floorDiv(-p.width(), (int) Math.pow(2, n + 1)),
						g + -Math.floorDiv(-p.height(), (int) Math.pow(2, n + 1)), pic[1][1].get(i, g));
			}
		}

		return newP;
	}

	/**
	 * Binary search for the string <code>s</code> in a list <code>t</code>. If
	 * <code>s</code> is in the list, then this method returns the index of the
	 * location of <code>s</code> in <code>t</code>; otherwise, this method
	 * returns the index where <code>s</code> would be located if it were to be
	 * inserted into the list <code>t</code>.
	 * 
	 * <p>
	 * This method does not modify the list <code>t</code>.
	 * 
	 * @pre t.size() is zero or more
	 * @pre1 t is in sorted order
	 * @pre2 t has no duplicate elements
	 * 
	 * @param s
	 *            a string
	 * @param t
	 *            a list
	 * @return the index of s if s is in the list; otherwise, returns the index
	 *         where s would be located if it were to be inserted into the list
	 */
	public static int bsearch(String s, List<String> t) {
		if (t.size() == 0)
			return 0;

		if (t.size() == 1) {
			if (s.compareTo(t.get(0)) > 0)
				return 1;
			else
				return 0;
		}

		List<String> list = new ArrayList<String>(t);

		int middle = (list.size() + 1) / 2;

		if (s.compareTo(list.get(middle)) < 0) {
			list = list.subList(0, middle);
			return bsearch(s, list);
		} else if (s.compareTo(list.get(middle)) > 0) {
			list = list.subList(middle, list.size());
			return middle + bsearch(s, list);
		} else {
			return middle;
		}

	}

	private static Color[][] clr(int x, int y, Picture p) {
		Color[][] value = new Color[x][y];
		for (int i = 0; i < x; i += 2) {
			for (int j = 0; j < y; j += 2) {
				int r = 0, g = 0, b = 0, count = 0;
				for (int s = 0; s < 2; s++) {
					for (int t = 0; t < 2; t++) {
						try {
							r += p.get(i + s, j + t).getRed();
							count++;
						} catch (Exception e) {

						}
					}
				}

				for (int s = 0; s < 2; s++) {
					for (int t = 0; t < 2; t++) {
						try {
							g += p.get(i + s, j + t).getGreen();
						} catch (Exception e) {

						}
					}
				}

				for (int s = 0; s < 2; s++) {
					for (int t = 0; t < 2; t++) {
						try {
							b += p.get(i + s, j + t).getBlue();
						} catch (Exception e) {

						}
					}
				}
				value[i / 2][j / 2] = new Color(r / count, g / count, b / count);
			}
		}

		return value;
	}

	public static void main(String[] args) {
		// RUN THIS TO TEST downsample
		Picture p = new Picture("FannyDog.jpg");
		p.show();
		downsample(p, 1).show();
		downsample(p, 2).show();
		downsample(p, 3).show();

		List<String> strings = new ArrayList<String>();
		for (int i = 0; i < 26; i++)
			strings.add((char) ((int) ('a') + i) + "");

		System.out.println(sum(4));
		String abc = "";
		for (String s : strings)
			abc += s;
		System.out.println(reverse(abc));

		System.out.println(bsearch("t", strings));

	}
}